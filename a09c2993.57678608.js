(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{82:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return c})),r.d(t,"metadata",(function(){return i})),r.d(t,"toc",(function(){return s})),r.d(t,"default",(function(){return l}));var n=r(3),o=r(7),a=(r(0),r(91)),c={id:"introduction",title:"Introduction",sidebar_label:"Introduction"},i={unversionedId:"introduction",id:"introduction",isDocsHomePage:!1,title:"Introduction",description:"Preventing re-renders is one of performance issues in React.",source:"@site/docs/introduction.md",slug:"/introduction",permalink:"/docs/introduction",version:"current",sidebar_label:"Introduction",sidebar:"docs",next:{title:"Quick Start",permalink:"/docs/quick-start"}},s=[],u={toc:s};function l(e){var t=e.components,r=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(n.a)({},u,r,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Preventing re-renders is one of performance issues in React.\nSmaller apps wouldn't usually suffer from such a performance issue,\nbut once apps have a central global state that would be used in\nmany components. The performance issue would become a problem.\nFor example, Redux is usually used for a single global state,\nand React-Redux provides a selector interface to solve the performance issue.\nSelectors are useful to structure state accessor,\nhowever, using selectors only for performance wouldn't be the best fit.\nSelectors for performance require understanding object reference\nequality which is non-trival for beginners and\nexperts would still have difficulties for complex structures."),Object(a.b)("p",null,'React Tracked is a library to provide so-called "state usage tracking."\nIt\'s a technique to track property access of a state object,\nand only triggers re-renders if the accessed property is changed.\nTechnically, it uses Proxies underneath, and it works not only for\nthe root level of the object but also for deep nested objects.'),Object(a.b)("p",null,"Prior to v1.6.0, React Tracked is a library to replace React Context\nuse cases for global state. React hook useContext triggers re-renders\nwhenever a small part of state object is changed, and it would cause\nperformance issues pretty easily. React Tracked provides an API\nthat is very similar to useContext-style global state."),Object(a.b)("p",null,'Since v1.6.0, it provides another building-block API\nwhich is capable to create a "state usage tracking" hooks\nfrom any selector interface hooks.\nIt can be used with React-Redux useSelector, and any other libraries\nthat provide useSelector-like hooks.'))}l.isMDXComponent=!0},91:function(e,t,r){"use strict";r.d(t,"a",(function(){return p})),r.d(t,"b",(function(){return b}));var n=r(0),o=r.n(n);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function c(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?c(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):c(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var u=o.a.createContext({}),l=function(e){var t=o.a.useContext(u),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=l(e.components);return o.a.createElement(u.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},f=o.a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,a=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=l(r),f=n,b=p["".concat(c,".").concat(f)]||p[f]||d[f]||a;return r?o.a.createElement(b,i(i({ref:t},u),{},{components:r})):o.a.createElement(b,i({ref:t},u))}));function b(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var a=r.length,c=new Array(a);c[0]=f;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:n,c[1]=i;for(var u=2;u<a;u++)c[u]=r[u];return o.a.createElement.apply(null,c)}return o.a.createElement.apply(null,r)}f.displayName="MDXCreateElement"}}]);